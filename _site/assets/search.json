[{"title":"Hiding content for accesibility","excerpt":"In web development, it’s safe to assume that it’s unavoidable to hide some elements or part of the content. Using only a single way of hiding content can harm accessibility, because users using assistive technologies won’t get the full context of the page the way the regular screen users do. In this article we are going to cover several ways of hiding elements, depending on accessibility.\n","content":"\n\nIn web development, it's safe to assume that it's unavoidable to hide some elements or part of the content. Using only a single way of hiding content can harm accessibility, because users using assistive technologies won't get the full context of the page the way the regular screen users do. In this article we are going to cover several ways of hiding elements, depending on accessibility.\n\nHiding content from all devices\n\nUsing CSS rules likedisplay: none; or visibility: hidden;, or HTML hidden attribute is the first thing that comes to mind when hiding elements or part of the content. Using these two CSS attributes will make both display devices and assistive technologies (like screen readers) to completely ignore the element and not present it to users.\n\n\nOf course, there are cases where we want to hide content from all devices. For example, we can use these CSS rules on elements in an accordion, tabs or other toggleable elements.\n\n\n\n\n\nHiding content from screen devices\n\nIn some cases, we want to hide some elements from displays, but we want to let assistive technologies present the visually hidden content to users. An example of that case, off the top of my head, are label-less inputs. Labels are usually hidden with display: none; but we would prefer if labels were accessible to the assistive technologies in order to provide more context to users.\n\nThis solution is a bit hacky, but very effective solution if we want to hide content from screen devices only. We can use the following CSS rule:\n\n\n.hidden--visually {\n    border: 0;\n    clip: rect(1px 1px 1px 1px);\n    clip: rect(1px, 1px, 1px, 1px);\n    height: 1px;\n    margin: -1px;\n    overflow: hidden;\n    padding: 0;\n    position: absolute;\n    width: 1px;\n}\n\n\n\nHiding content from assistive devices\nThere are cases where we would like to hide the content from screen readers and other assistive technologies. For example, if we have an image carousel, with \"previous\" button on the beginning, carousel images in the middle and \"next\" button on the end, we don't want the screen reader to read it out in that order. We can provide a separate, more accessible controls which are visually hidden, but hide the \"previous\" and \"next\" buttons from assistive devices.\n\nIn cases where we want to hide content from the assistive devices, we can use the aria-hidden=\"true\" HTML attribute.\n\nOverride quirk\nIt's important to note that CSS rules like display: none; will override the aria-hidden=\"false\" and the content will be ignored by assistive technologies. \n\n","url":"/blog/development/hiding-elements-accessibility.html"},{"title":"Mastering CSS: Vertical Rhythm","excerpt":"Vertical rhythm is a very simple concept in web design and web development. It makes the page feel consistent and visually plesant. Maintaining the rhythm accross the site, especially on larger collaborative projects, can be quite a challenge. With SASS, LESS and now the CSS variables, configuring and maintaining the vertical rhythm has never been easier. In this article, we are going to cover the very basics of vertical rhythm and how to implement it using CSS variables.\n","content":"\n\nVertical rhythm is an important concept in web design and development. It makes the page and typography feel consistent and visually pleasant. Maintaining the rhythm accross the site, especially on larger collaborative projects, can be quite a challenge. With SASS, LESS and now the CSS variables, configuring and maintaining the vertical rhythm has never been easier. In this article, we are going to cover the very basics of vertical rhythm and how to implement it using CSS variables and CSS calc function.\n\nVertical rhythm basics\n\nVertical rhythm is usually used on following CSS properties:\n\nTypography -  line-height\nSpacing - padding (top and bottom), margin (top and bottom)\nOffsets - top, bottom\nSize - height, min-height,  max-height \n\nNotice how we don't use vertical rhythm for font-size. Modular scale is usually used for font sizes in typography. Vertical rhythm is only used for spacing and vertical size.\n\nFirst off, we need to determine the rhythm unit. This will act as a base for multiplication for calculating vertical ryhthm. Since vertical rhythm is tied with repetition, and the most repetitive spacing on any website is a line-height of body element, the base line-height of a page. We'll use this base line-height as rhythm-unit.\n\n\n\n\nhtml {\n    /* Set parent font size */\n    font-size: 18px;\n}\n\nbody {\n    /* Set base line-height */\n    line-height: 1.778rem;\n}\n\n\n\nNote that we are using px value for easier calculation, it's recommended to use relative values wherever you can. From this configuration, we can calculate rhythm unit value: Rhythm unit = 18px * 1.778rem = 32px. Alternatively, we can check the line-height of the body element in element inspector.\n\n\n\n\nVertical rhythm example with 32px rhythm unit from this article (very meta!)\n\n\n\nOn the image, we can see the baseline grid of 32px (1 rhythm unit) and how text fits nicely into it. Notice how the heading's line-height is exactly 2 times the base rhythm unit. That means that heading's line height has rhythm unit multiplier of 2 (with bottom margin of 1 rhythm unit).\n\n\n\nRhythm unit multipliers\nOf course, we can't have only one spacing value. This is where rhythm unit multipliers come in.\n\n\nhtml {\n    /* Set parent font size */\n    font-size: 18px;\n}\n\nbody {\n    /* rhythmUnit = 32px */\n    line-height: 1.778rem;\n}\n\n.spacing__vertical--1 {\n    /* 1x rhythmUnit = 32px */\n    padding-bottom: 1.778rem;\n}\n\n.spacing__vertical--2 {\n    /* 2x rhythmUnit = 64px */\n    padding-bottom: 3.556rem;\n}\n\n.spacing__vertical--3 {\n    /* 3x rhythmUnit = 96px */\n    padding-bottom: 5.334rem;\n}\n\n\n\nWe have our basic classes for spacing which are calculated by multiplying the rhythm unit by 2, 3, 4, etc. But these classes are not flexible enough and they won't cover all of the use-cases for vertical rhythm. That's why we will create CSS variables (also can be done in SASS and LESS) to store and dynamically calculate the vertical rhythm values.\n\n\n:root {\n    /* Base values */\n    --typography__fontSize: 18px;\n    --spacing__rhythmUnit: 1.778rem; /* 1.778rem * 18px = 32px */\n\n    /* Calculations */\n    --spacing__vertical--1: var(--spacing__rhythmUnit);\n    --spacing__vertical--2: calc(2 * var(--spacing__rhythmUnit));\n    --spacing__vertical--3: calc(3 * var(--spacing__rhythmUnit));\n}\n\nhtml {\n    font-size: var(--typography__fontSize);\n}\n\nbody {\n    line-height: var(--spacing__vertical--1);\n}\n\n.spacing--default {\n    padding-bottom: var(--spacing__vertical--1);\n}\n\n.button--default {\n    height: var(--spacing__vertical--2);\n}\n\n.heading--primary {\n    line-height: var(--spacing__vertical--3);\n}\n\n\n\nWe have improved upon the previous example and created reusable variables that we can use for all mentioned use-cases (typography, spacing, offset, height, etc.). By using these variables, we can ensure the consistent vertical rhythm of all elements on the website. But we need to keep in mind when we add some CSS rules (like borders) that push the content down and don't have to adhere to rules of vertical rhythm.\n\n\n\nCompensating for borders\nWhen we add vertical (top or bottom) borders to an element, they add to the overall height of the element and push the content down. This also affects our vertical rhythm (if border width is not in vertical rhythm value) and we have to compensate for adding vertical borders by either reducing the rhythm value of vertical padding, margin or line-height(if element has no padding or margin).\n\n\n:root {\n    /* Base values */\n    --typography__fontSize: 18px;\n    --spacing__rhythmUnit: 1.778rem; /* 1.778rem * 18px = 32px */\n\n    --border__width--default: 0.111rem; /* 2px */\n\n    /* Calculations */\n    --spacing__vertical--1: var(--spacing__rhythmUnit);\n    --spacing__vertical--2: calc(2 * var(--spacing__rhythmUnit));\n    --spacing__vertical--3: calc(3 * var(--spacing__rhythmUnit));\n}\n\nhtml {\n    font-size: var(--typography__fontSize);\n}\n\nbody {\n    line-height: var(--spacing__vertical--1);\n}\n\n.heading--primary {\n    border-bottom: var(--border__width--default) solid #aaa; /* 2px */\n    padding-bottom: calc(\n        var(--spacing__vertical--1) - var(--border__width--default)\n    ); /* 32px - 2px */\n    line-height: var(--spacing__vertical--3); /* 96px */\n}\n\n\n\nTaking a look at the .heading--primary class, we can see that we have set a bottom border, padding and line-height. Since we have padding, we are going to compensate for added bottom border by reducing the width of the border from bottom padding.\n\nIf we assume that the heading takes one line of text, have the following calculation of the element's height: 2px + (32px - 2px) + 96px = 128px which is equal to 4 times the vertical unit.\n\n","url":"/blog/development/mastering-css-vertical-rhythm.html"},{"title":"Magic Numbers in CSS","excerpt":"Magic numbers can be seen as very benign on smaller projects, examples and individual cases, but they can really make our jobs difficult when adding new features, fixing issues and maintaining the website. Soon you’ll find yourself adding magic numbers to fix issues caused by other magic numbers, but also potentially causing new issues down the line.\n","content":"\n\nWe've all seen magic numbers in code, didn't we? The magical padding-top: 2px; and top: 136px; - like randomly-spread pieces of bubblegum holding the house of cards together. Code should be easily read, self-explanitory and have a logical structure.\n\nMagic numbers can be seen as very benign on smaller projects, examples and individual cases, but they can really make our jobs difficult when adding new features, fixing issues and maintaining the website. Soon you'll find yourself adding magic numbers to fix issues caused by other magic numbers, but also potentially causing new issues down the line.\n\nSolution starts with the design\n\n\nWhen a project has a design phase which results with a design file with style guide, component, modules, pages, etc. we usually have all the information about color, typography, horizontal grids, and media query variables, but those are just a few of many variables that can repeat throughout the website. What about horizontal and vertical spacing (vertical rhythm), or borders, or shadows, container widths, image aspect ratios, z-indices, etc.\n\n\nThe more variables are defined in the design phase and the more design is constrained within those variables, the less we rely on magic numbers since we can see the connection between all design elements. For example, Defining a rhythm unit can add a better context of vertical spacing. Now if we see that header is at 96px height, and if we know that our base line height is 32px, we can see that all elements in header container follow the rules of vertical rhythm. This allows us to establish a better connection between a style guide variable (rhythm unit) and a complex module (header).\n\n\n\n\nDiscipline makes strong developers\n\nFor better or worse, nothing stops us from using Magic numbers in CSS. The code will work the same if we write a value or a variable that contains the value. No linter or preprocessor will throw an error. It's up to a developer to learn the best practices, go beyond the call of duty and make quality long-term decisions. When starting a new project, outlining and defining CSS variables is very important. Quality, readability and maintainability of your code will depend on how well you define those variables: giving them a meaningful name, grouping the variables properly, defining a clear dependency between the variables, etc.\n\nLet's demonstrate this with the following code. Please note that, in this example, I'm using PostCSS and modern CSS syntax. But this philosophy also applies to CSS Preprocessors like SASS and LESS.\n\n\n:root {\n    /* px definitions for easier calculations */\n    /* These variables are only used for calculation, we ommit the px because calc cannot strip units */\n    --typography__fontSize--px: 16;\n    --typography__lineHeight--px: 27;\n\n    --browser__fontSize--default: 16;\n\n    /* Basic typography setup, establishing rhythm unit */\n    /* These variables should be assigned to the CSS attributes */\n    --typography__fontSize: calc(\n        (var(--typography__fontSize--px) / var(--browser__fontSize--default)) * 1rem\n    );\n    --typography__lineHeight: calc(\n        (var(--typography__lineHeight--px) / var(--typography__fontSize--px)) * 1rem\n    );\n\n    /* Calculating vertical rhythm variables */\n    /* Can be located in separate file if using Preprocessors or PostCSS import */\n    --spacing__vertical--1: var(--typography__lineHeight);\n    --spacing__vertical--2: calc(2 * var(--spacing__vertical--1));\n    --spacing__vertical--3: calc(3 * var(--spacing__vertical--1));\n\n    /* Defining custom variables for modules */\n    /* Can be located in separate file if using Preprocessors or PostCSS import */\n    --header__height: var(--spacing__vertical--3);\n}\n\n\n\n\nNotice how we used only two numbers and how the rest of the variables are linked to those two numbers. I've used my way of naming the variables, with the BEM-like structure group__attributeName--variation. The connection between the variables is clear: base rhythm unit is equal to the base line height which rem value is calculated using px values of font size and line height. Similarly, header has a fixed height which equals rhythm unit multiplier of 3, whih is calculated along with the rest rhythm unit multipliers (vertical spacings).\n\nWith variables being organized this way, we can easily add more complexity to our code and avoid repeating values or variables, and avoid using magic numbers alltogether. But...\n\nSometimes, using Magic Numbers is unavoidable\nDue to the hacky nature of CSS and varying browser support, sometimes the only solution is to use Magic Numbers. Even in that case, Magic number should be saved and documented in a variable in the same file it's used. Magic number that apply to a single element should not be defined along the global variables. That way, any developer will understand the scope and role of the variable and may want to remove it in the future, if needed.\n\n\n/* element.css */\n\n:root {\n    /* Browser-specific bug, expected to be fixed in the future */\n    --element__spacing--magic: -1px;\n}\n\n.element {\n    margin-top: var(--element__spacing--magic);\n}\n\n","url":"/blog/development/magic-nunbers-in-css.html"}]